const cds = require('..'), { path } = cds.utils
const LOG = cds.log('i18n')

/**
 * Instances of this class are used to fetch and read i18n resources from the file system.
 */
class I18nResources {

  constructor (options) {
    for (let each in options) super[each] = options[each]
  }


  /**
   * The folders to search for i18n files in. By default a shortcut to i18n.folders
   * config but can be specified in constructor.
   */
  get folders() {
    return super.folders = cds.env.i18n.folders
  }


  /**
   * Returns the files basename to read properties from; default is `'i18n'`.
   * @returns {string}
   */
  get file() {
    return super.file ??= cds.env.i18n.file
  }


  /**
   * Fetches all i18n files matching {@link file basename} in {@link folders} up to {@link roots}.
   * @returns {Record<string,string[]>} a dictionary of files by folders.
   */
  get files() {

    // prepare the things we need below...
    const { existsSync: exists, readdirSync: readdir } = cds.utils.fs
    const _folders = I18nResources.folders ??= {}
    const _entries = I18nResources.entries ??= {}
    const basename = RegExp(`${this.file}[._]`)
    const files_by_folders = {} // the result to be returned

    // fetch relatively specified i18n.folders in the neighborhood of sources...
    const relative_folders = this.folders.filter (f => f[0] !== '/')
    if (relative_folders.length) {
      const visited = {}, roots = this.roots, $sources = this.model?.$sources
      const $sourcedirs = $sources ? [ ...new Set($sources.map(path.dirname)) ].reverse() : [ cds.home, cds.root ]
      $sourcedirs.forEach (function _visit (dir) {
        if (dir in visited) return; else visited[dir] = true
        LOG.debug ('searching for i18n files in the neighborhood of', dir)
        // is there an i18n folder in the currently visited directory?
        for (let each of relative_folders) {
          const f = path.join(dir,each), _exists = _folders[f] ??= exists(f)
          if (_exists && _add_entries4(f)) return // stop at first match from i18n.folders
        }
        // else recurse up the folder hierarchy till reaching package roots ...
        if (roots.includes(dir) || exists(path.join(dir,'package.json'))) return
        else _visit (path.dirname(dir))
      })
    }

    // fetch fully specified i18n.folders, i.e., those starting with /
    const specific_folders = this.folders.filter (f => f[0] === '/')
    for (let f of specific_folders) {
      const _exists = _folders[f] ??= exists(f)
      _add_entries4 (_exists ? f : path.join(cds.root,f))
    }

    // helper to add matching files from found folder, if any
    function _add_entries4 (f) {
      const files = (_entries[f] ??= readdir(f)) .filter (f => f.match(basename))
      if (files.length) return files_by_folders[f] = files
    }

    // finally return the collected files by folders
    super.folders = Object.keys (files_by_folders)
    return super.files = files_by_folders
  }


  /**
   * The root directories up to which to search for {@link files `i18n.files`}.
   */
  get roots() {
    return super.roots = [ cds.env.i18n.root || cds.root ]
  }


  /**
   * Returns all locales for which translations are available in this.{@link files}.
   * @returns {string[]}
   */
  get locales() {
    const unique_locales = new Set(), {path} = cds.utils
    for (let [folder,files] of Object.entries(this.files)) {
      for (let file of files) {
        const { name, ext } = path.parse (file); switch (ext) {
          case '.properties': unique_locales.add(/(?:_(\w+))?$/.exec(name)?.[1]||''); break
          case '.json': for (let locale in _load_json(path.join(folder,file))) unique_locales.add(locale); break
          case '.csv': return _load_csv (path.join(folder,file))[0].slice(1)
        }
      }
    }
    return super.locales = [...unique_locales]
  }


  /**
   * Loads content from all files for the given locale.
   * @returns {entries[]} An array of entries, one for each file found.
   */
  content4 (locale, suffix = locale?.replace(/-/g,'_')) {
    const content = [], { file, files } = this
    for (let folder in files) {
      const all = this.content4[folder] ??= _load('json',folder) || _load('csv',folder)
      if (all) { if (locale in all) content.push (all[locale]); continue }
      const props = _load ('properties', folder, file + (suffix ? '_'+suffix : ''))
      if (props) content.push (props)
    }
    function _load (kind, folder, basename = file) {
      const entry = `${basename}.${kind}`; if (!files[folder].includes(entry)) return
      const file = path.join (folder, entry)
      try { switch (kind) {
        case 'properties': return _load_properties (file)
        case 'json': return _load_json (file)
        case 'csv': return _load_csv (file)
      }} finally {
        LOG.debug ('read:', file)
      }
    }
    return content
  }
}


const _load_properties = cds.load.properties
const _load_json = require
const _load_csv = file => {
  const csv = cds.load.csv(file); if (!csv) return
  const [ header, ...rows ] = csv, all = {}
  header.slice(1).forEach ((lang,i) => {
    const entries = all[lang] = {}
    for (let row of rows) if (row[i]) entries[row[0]] = row[i]
  })
  return all
}

module.exports = I18nResources
