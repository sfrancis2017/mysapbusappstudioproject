// Create a hierarchical expression tree from an `xpr` array

// See ./CdlGrammar.js for the operator precedences.


'use strict';


const prefixOperators = {     // see <prec=…,prefix> in `expression` of CdlGrammar
  __proto__: null,
  new: 33,                  // special in CDL (only before ref), clarify with `.`
  exists: 33,               // special in CDL
  '+': 30,                  // note: binary `.` and `over` have higher precedence!
  '-': 30,
  not: 8,
};

const binaryOperators = {
  __proto__: null,
  '.': 37,                      // nary
  over: 35,                     // TODO: only after ref with arg?
  '*': 24,                      // nary
  '/': 24,
  '+': 22,
  '-': 22,
  '||': 20,
  '=': 10,                      // with ANY/SOME/ALL
  '<>': 10,
  '>': 10,
  '>=': 10,
  '<': 10,
  '<=': 10,
  '!=': 10,
  '==': 10,                     // not supported yet in CDL or backends
  and: 4,
  or: 2,
  // with second token or ternary (in the grammar, these ops have prec=10, but
  // also assoc=none, i.e. could not be used without parens together):
  is: 11,                       // is binary op here, not postfix
  in: 13,
  between: 13,
  like: 13,
  not: 15,                      // specially handled
};

const secondTokens = {
  // the value is the precedence of the first token listed in `binaryOperators`
  __proto__: null,
  any: 10,                      // for `=` etc
  some: 10,
  all: 10,
  not: 11,                      // for `is`
  between: 15,                  // for `not`
  in: 15,
  like: 15,
};

const naryOperators = {
  __proto__: null,
  '.': true,                    // CSN-tree really as left-assoc binary?
  '*': true,
  '/': true,
  '+': true,
  '-': true,
  '||': true,
  and: true,
  or: true,
  between: 'and',
  like: 'escape',
};


class XprTree {
  nodes;                        // array value of CSN property `xpr`/`where`/…
  nodeIdx = 0;
  args;        // corresponding XSN array, with already tree-like sub expressions
  location;

  constructor( nodes, args, location ) {
    this.nodes = nodes;
    this.args = args;
    this.location = location;
  }

  tree() {
    const args = [];
    const { length } = this.args;
    while (this.nodeIdx < length) {
      const expr = this.expression( -1 );
      if (expr)
        args.push( expr );
    }
    return (args.length === 1) ? args[0] : this.create( args );
  }

  expression( parentPrec ) {
    let append;
    let naryOp;
    let args;

    // Term = ref/val or unary operator with expression as operand
    let expr = this.args[this.nodeIdx];
    if (!expr)
      return expr;
    let node = this.nodes[this.nodeIdx++];
    if (typeof node === 'string') {
      const prec = prefixOperators[node]; // <prec=…,prefix> in CdlGrammar
      if (prec) {
        const right = this.expression( prec - 1 );
        if (!right)
          return expr;
        expr = this.create( [ expr, right ] );
      }
      else if (node === 'case') {
        expr = this.caseWhen( [ expr ] );
      }
      else {             // unknown token (keyword in CDL):
        return expr;            // …from fns with irregular syntax?
        // also handles `null` as right side of `is` in `is null`
        // TODO: `(` from CSN v0.x ?
        // It is important not to handle binary ops after this, because otherwise
        // we would not properly parse functions with irregular syntax
      }
    }

    node = this.nodes[this.nodeIdx];
    while (typeof node === 'string') {
      const prec = binaryOperators[node]; // <prec=…> in CdlGrammar
      if (!prec || parentPrec >= prec)
        return expr;

      // handle n-ary operators including ternary
      append = (typeof naryOp === 'string')
        ? !append && naryOp     // `and` after `between`, `escape` after `like`˛
        : naryOp && node;       // nary operators like `+`
      if (node === append) {
        args.push( this.args[this.nodeIdx++] );
      }
      else {
        naryOp = naryOperators[node];
        append = false;
        args = [ expr, this.args[this.nodeIdx++] ];
        expr = this.create( args, naryOp === true );
      }

      // handle second token of operator:
      const second = this.nodes[this.nodeIdx];
      if (typeof second === 'string' && secondTokens[second] === prec && !append) {
        args.push( this.args[this.nodeIdx++] );
        if (node === 'not')
          naryOp = naryOperators[second];
      }

      // the right side
      const right = this.expression( prec );
      if (!right)                   // incomplete
        return expr;
      args.push( right );
      node = this.nodes[this.nodeIdx];
      // TODO: simplyfy between-and and like-escape with pushTokenAndExpression()
    }
    return expr;
  }

  caseWhen( args ) {
    const expr = this.create( args );
    let node = this.nodes[this.nodeIdx];
    if (node !== 'when') {
      const value = this.expression( -1 );
      if (value)
        args.push( value );
      node = this.nodes[this.nodeIdx];
    }
    while (node === 'when') {
      node = this.pushTokenAndExpression( args );
      if (node === 'then')
        node = this.pushTokenAndExpression( args );
    }
    if (node === 'else')
      node = this.pushTokenAndExpression( args );
    if (node === 'end')
      args.push( this.args[this.nodeIdx++] );
    return expr;
  }

  pushTokenAndExpression( args ) {
    args.push( this.args[this.nodeIdx++] );
    const value = this.expression( -1 );
    if (value)
      args.push( value );
    return this.nodes[this.nodeIdx];
  }

  create( args, isNary = false ) {
    // could be adopted for CSN expression tree
    return {
      op: { val: (isNary ? 'nary' : 'ixpr'), location: this.location },
      location: this.location,
      args,
    };
  }
}

module.exports = {
  xprAsTree: ( nodes, args, location ) => (new XprTree( nodes, args, location )).tree(),
};
